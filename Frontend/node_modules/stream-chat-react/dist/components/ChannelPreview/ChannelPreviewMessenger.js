import React, { useEffect, useRef } from 'react';
import clsx from 'clsx';
import { Avatar as DefaultAvatar } from '../Avatar';
import { useChatContext } from '../../context';
export var MarkChannelReadOn;
(function (MarkChannelReadOn) {
    MarkChannelReadOn[MarkChannelReadOn["never"] = 0] = "never";
    MarkChannelReadOn[MarkChannelReadOn["leave"] = 1] = "leave";
    MarkChannelReadOn[MarkChannelReadOn["reenter"] = 2] = "reenter";
})(MarkChannelReadOn || (MarkChannelReadOn = {}));
var UnMemoizedChannelPreviewMessenger = function (props) {
    var _a, _b;
    var active = props.active, activeChannel = props.activeChannel, _c = props.Avatar, Avatar = _c === void 0 ? DefaultAvatar : _c, channel = props.channel, _d = props.className, customClassName = _d === void 0 ? '' : _d, displayImage = props.displayImage, displayTitle = props.displayTitle, latestMessage = props.latestMessage, _e = props.markActiveChannelReadOn, markActiveChannelReadOn = _e === void 0 ? MarkChannelReadOn.reenter : _e, customOnSelectChannel = props.onSelect, setActiveChannel = props.setActiveChannel, unread = props.unread, watchers = props.watchers;
    var client = useChatContext('ChannelPreviewMessenger').client;
    var channelPreviewButton = useRef(null);
    var avatarName = displayTitle || ((_b = (_a = channel.state.messages[channel.state.messages.length - 1]) === null || _a === void 0 ? void 0 : _a.user) === null || _b === void 0 ? void 0 : _b.id);
    var previouslyClicked = useRef(active);
    var handleMarkReadOnReenter = function () {
        if (!client.user)
            return;
        var ownReadState = channel.state.read[client.user.id];
        if (!previouslyClicked.current) {
            previouslyClicked.current = true;
        }
        else if (!active &&
            ((ownReadState === null || ownReadState === void 0 ? void 0 : ownReadState.first_unread_message_id) || (ownReadState === null || ownReadState === void 0 ? void 0 : ownReadState.unread_messages) > 0) &&
            previouslyClicked.current) {
            channel.markRead();
        }
    };
    var handleMarkReadOnLeave = function () {
        if (!(client.user && activeChannel))
            return;
        var ownReadState = activeChannel.state.read[client.user.id];
        if ((ownReadState === null || ownReadState === void 0 ? void 0 : ownReadState.first_unread_message_id) || (ownReadState === null || ownReadState === void 0 ? void 0 : ownReadState.unread_messages) > 0) {
            activeChannel.markRead();
        }
    };
    var onSelectChannel = function (e) {
        if (customOnSelectChannel) {
            customOnSelectChannel(e);
        }
        else if (setActiveChannel) {
            // eslint-disable-next-line default-case
            switch (markActiveChannelReadOn) {
                case MarkChannelReadOn.never:
                    break;
                case MarkChannelReadOn.leave:
                    handleMarkReadOnLeave();
                    break;
                case MarkChannelReadOn.reenter:
                    handleMarkReadOnReenter();
            }
            setActiveChannel(channel, watchers);
        }
        if (channelPreviewButton === null || channelPreviewButton === void 0 ? void 0 : channelPreviewButton.current) {
            channelPreviewButton.current.blur();
        }
    };
    useEffect(function () {
        if (markActiveChannelReadOn !== MarkChannelReadOn.reenter)
            return;
        var handleEvent = function (event) {
            var _a, _b;
            if (active)
                return;
            if (channel.cid !== event.cid)
                return;
            if (event.type === 'notification.mark_unread' && ((_a = event.user) === null || _a === void 0 ? void 0 : _a.id) !== ((_b = client.user) === null || _b === void 0 ? void 0 : _b.id))
                return;
            previouslyClicked.current = false;
        };
        channel.on('notification.mark_unread', handleEvent);
        channel.on('message.new', handleEvent);
        return function () {
            channel.off('notification.mark_unread', handleEvent);
            channel.off('message.new', handleEvent);
        };
    }, [active, channel, client, markActiveChannelReadOn, previouslyClicked]);
    return (React.createElement("button", { "aria-label": "Select Channel: ".concat(displayTitle || ''), "aria-selected": active, className: clsx("str-chat__channel-preview-messenger str-chat__channel-preview", active && 'str-chat__channel-preview-messenger--active', unread && unread >= 1 && 'str-chat__channel-preview-messenger--unread', customClassName), "data-testid": 'channel-preview-button', onClick: onSelectChannel, ref: channelPreviewButton, role: 'option' },
        React.createElement("div", { className: 'str-chat__channel-preview-messenger--left' },
            React.createElement(Avatar, { image: displayImage, name: avatarName, size: 40 })),
        React.createElement("div", { className: 'str-chat__channel-preview-messenger--right str-chat__channel-preview-end' },
            React.createElement("div", { className: 'str-chat__channel-preview-end-first-row' },
                React.createElement("div", { className: 'str-chat__channel-preview-messenger--name' },
                    React.createElement("span", null, displayTitle)),
                !!unread && (React.createElement("div", { className: 'str-chat__channel-preview-unread-badge', "data-testid": 'unread-badge' }, unread))),
            React.createElement("div", { className: 'str-chat__channel-preview-messenger--last-message' }, latestMessage))));
};
/**
 * Used as preview component for channel item in [ChannelList](#channellist) component.
 * Its best suited for messenger type chat.
 */
export var ChannelPreviewMessenger = React.memo(UnMemoizedChannelPreviewMessenger);
